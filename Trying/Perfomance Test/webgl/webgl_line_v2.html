
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
       <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
       <title></title>
      	<script src="../jquery.min.js"></script>
      	<script src="../app.js"></script>
      	<script src="../stats.js"></script>
      
    
		<script id="shader-fs" type="x-shader/x-fragment">
		    precision mediump float;
		    
		    varying vec4 vColor;
		    
		    void main(void) {
		        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
		    }
		</script>
		
		<script id="shader-vs" type="x-shader/x-vertex">
		    attribute vec4 aVertexPosition;
			attribute vec4 aVertexColor;
			
			varying vec4 vColor;

		    void main(void) {
		        gl_Position = aVertexPosition;
		        vColor  = aVertexColor;
		    }
		</script>  
		
		<script>
			function getShader(gl, id) {
		        var shaderScript = document.getElementById(id);
		        if (!shaderScript) {
		            return null;
		        }
		        var str = "";
		        var k = shaderScript.firstChild;
		        while (k) {
		            if (k.nodeType == 3) {
		                str += k.textContent;
		            }
		            k = k.nextSibling;
		        }
		        var shader;
		        if (shaderScript.type == "x-shader/x-fragment") {
		            shader = gl.createShader(gl.FRAGMENT_SHADER);
		        } else if (shaderScript.type == "x-shader/x-vertex") {
		            shader = gl.createShader(gl.VERTEX_SHADER);
		        } else {
		            return null;
		        }
		        gl.shaderSource(shader, str);
		        gl.compileShader(shader);
		        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		            alert(gl.getShaderInfoLog(shader));
		            return null;
		        }
		        return shader;
		    }
	</script>
      	
    <script>
		var points_data,stats,formated_points,interval_counter,gl;
		var webGLProgramObject, // "GPU-Programm", das zur Berechnung der Grafik verwendet wird
            vertexAttribLoc,  // Verkn√ºpfung zwischen JavaScript und Vertex-Shader
            vVertices,        // Array der Dreieckskoordinaten
            vertexPosBufferObjekt; // Der WebGL-Buffer, der die Dreieckskoordinaten aufnimmt
    		interval_counter=0;  
    		 
       $(document).ready( function() {
    		stats = stats();
			$.getJSON( "../api/data.json", function( data ) {
				canvas = window.document.getElementById("webglcanvas");
				points_data = data.data;
				$('#linescount').html(data.count)
				formated_points_one = createPointsArray(0);
				formated_points_two = createPointsArray(2);
			
				setTimeout(function(){
					meinWebGLStart(); 
				},1000);
			
			})
				
		});	

    
		var canvas,points;

		function meinWebGLStart(){

	        try {
	            gl = canvas.getContext("experimental-webgl");
	        } catch (e) {}
	        if (!gl) {
	            window.alert("Fehler: WebGL-Context nicht gefunden");
	        }

	        var fragmentShader = getShader(gl,"shader-fs");   
	        var vertexShader = getShader(gl,"shader-vs");   
	        
	        webGLProgramObject = gl.createProgram();
	       
	        gl.attachShader(webGLProgramObject, fragmentShader);
			gl.attachShader(webGLProgramObject, vertexShader);
	
	        // Das Shader-Program-Objekt ist vollstaendig und muss
	        // gelinkt werden.
	        gl.linkProgram(webGLProgramObject);
	        
	        // Da theoretisch mehrere Shader-Program-Objekte moeglich  
	        // sind, muss angegeben werden, welches benutzt werden soll.
	        gl.useProgram(webGLProgramObject);
	        
	        // RGB-Alpha Farbe zum loeschen des Hintergrundes:
	        gl.clearColor(255.0, 255.0,255.0, 1.0);
	        // Hintergrund loeschen
	        gl.clear(gl.COLOR_BUFFER_BIT);
	
	        // Die Verknuepfung zwischen JavaScript und dem 
	        // Shader-Attribut
	        webGLProgramObject.vertexAttribLoc = gl.getAttribLocation(webGLProgramObject, "aVertexPosition");
			webGLProgramObject.vertexColor = gl.getAttribLocation(webGLProgramObject, "aVertexC");

			requestAnimationFrame( drawStuff );
	
	    }
	    
	    function drawStuff(){
	    	  	stats.begin();
			
	    		interval_counter++;	
				$('#counter').html("Redraw Count:"+interval_counter);	
				stats.begin();
				var points_array = new Array(formated_points_one,formated_points_two);	
	
				for(var i = 0; i < $("#chanels").val(); i++){
					vVertices = points_array[i];
                                  
                    // Buffer wird erstellt...GPU   
			        vertexPosBufferObjekt = gl.createBuffer();
			        // ...und als aktives Objekt gesetzt:
			        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBufferObjekt);
			        
			         // die Arraydaten werden an den aktiven Puffer uebergeben:
			        gl.bufferData(gl.ARRAY_BUFFER, vVertices, gl.STATIC_DRAW);
			        gl.vertexAttribPointer(webGLProgramObject.vertexAttribLoc, 3, gl.FLOAT, false, 0, 0);
			        gl.enableVertexAttribArray(vertexAttribLoc);
			
					if($('#limit_lines').val() < vVertices.length/3){
						draw_count = $('#limit_lines').val();
					}else{
						draw_count = vVertices.length/3;
					}
			        gl.drawArrays(gl.LINE_STRIP, 0, draw_count);
		        }
		        stats.end();
		        
		        requestAnimationFrame( drawStuff );
	    }
	    
		function createPointsArray(chanel){
			console.log(chanel);
			var x_range = 0;
			var points_pixel = points_data;
	
			var points_string = "-1.0, 1.0,0.0";
			points = new Float32Array(points_pixel.length*3);
			$.each(points_pixel, function(i,val){
				y_range = (val['chanels'][chanel].value/50);
				//console.log(y_range);
				x_range += 0.01;
				points_string += ","+pixelToPoints(i,new Array(x_range,y_range))
			});
	    
			return points             
		};
		
		// helpfer function for point generation - by Michi
		function pixelToPoints(index,point){
			var x = 0;
			var y = 0;
			if(point[0] < canvas.width/2){
				if(point[0] > 0){
					x = (100-(((100/(canvas.width/2))*point[0])))*-0.01;
				}else{
					x = -1;
				}	
			}else if(point[0] > canvas.width/2){
				x = ((((100/(canvas.width/2))*point[0])))*0.01;
			}
		
			if(point[1] < canvas.height/2){
				if(point[1] > 0){
					y = (100-(((100/(canvas.height/2))*point[1])))*0.01;
				}else{
					y = -1;
				}	
			}else if(point[1] > canvas.height/2){
				y = (100-(((100/(canvas.height/2))*point[1])))*0.01;
			}
	
			points[(index*3)] = x;
			points[(index*3)+1] = y;
			points[(index*3)+2] = 0.0;
	
		}

    </script>
    
    </head>
    <body>
    	<h1 style="text-align:center;">Web GL Path - no simplify</h1>

     <canvas id="webglcanvas" width="1600" height="500">
     	
     </canvas> 

<p>Data exists for <a id="linescount"></a> Points</p>
<p>Value for max points:<input id="limit_lines" value="50000" type"name"/></p>
<p>Channels: <select id="chanels"><option val="0">1</option><option val="1">2</option></select></p>
<p id="counter"></p>  
     
     
    </body>
</html>

