
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
       <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
       <title>WebGL Tutorial 1 - Das erste Dreieck</title>
      <script src="../jquery.min.js"></script>
      	<script src="../app.js"></script>
      	<script src="../stats.js"></script>
      	
    <script type="text/javascript">
    var points_data,stats,formated_points,interval_counter,gl;
    
      var
          
            webGLProgramObject, // "GPU-Programm", das zur Berechnung der Grafik verwendet wird
            vShaderQuellcode, // String des Vertex-Shader Quellcodes
            vShader,          // der Shader selbst
            fShaderQuellcode, // String des Fragment-Shader Quellcodes
            fShader,          // der Shader selbst
            vertexAttribLoc,  // Verkn√ºpfung zwischen JavaScript und Vertex-Shader
            vVertices,        // Array der Dreieckskoordinaten
            vertexPosBufferObjekt; // Der WebGL-Buffer, der die Dreieckskoordinaten aufnimmt
    			interval_counter=0;
       $(document).ready( function() {
        	
        		stats = stats();
			

				$.getJSON( "../api/data.json", function( data ) {
					 canvas = window.document.getElementById("meineWebGLCanvas");
					points_data = data.data;
					$('#linescount').html(data.count)
					formated_points_one = createPointsArray(0);
					formated_points_two = createPointsArray(2);
				
					setTimeout(function(){

						meinWebGLStart(); 
					
					},1000);
				
				})
				
		});	
    
    "use strict";
    /*global window */  // tells jslint that 'window' is defined!
    /*global Float32Array */  // tells jslint that 'Float32Array' is defined!
	var canvas,points;
    // Diese Funktion wird ausgefuehrt, sobald die HTML-Seite geladen ist :
    function meinWebGLStart() {
      

       

        try {
            // Falls der Browser es unterstuetzt, wird hier WebGL 
            // erstmalig  angesprochen und der "WebGL-Context" in 
            // dem Objekt gl gespeichert.
            gl = canvas.getContext("experimental-webgl");
        } catch (e) {}
        if (!gl) {
            window.alert("Fehler: WebGL-Context nicht gefunden");
        }

        // Das Shader-Program-Objekt fasst spaeter den Vertex- 
        // und Fragment-Shader zusammen.
        webGLProgramObject = gl.createProgram();

        // Der folgende String enthaelt den kompletten Quellcode
        //  fuer einen minimalistischen Vertex-Shader:  
        vShaderQuellcode =
            'attribute vec4 vPosition; \n\
            void main() \n\
            { \n\
                gl_Position = vPosition; \n\
            } \n';
        // Das Vertex-Shader-Objekt wird angelegt:                                
        vShader = gl.createShader(gl.VERTEX_SHADER);
        //           - mit seinem Quelltext verknuepft:
        gl.shaderSource(vShader, vShaderQuellcode);
        //           - kompiliert:
        gl.compileShader(vShader);
        //           - dem Shader-Program-Objekt hinzugefuegt:
        gl.attachShader(webGLProgramObject, vShader);

        // Nochmal das gleiche Vorgehen wie fuer den Vertex-
        // Shader; analog fuer den Fragment-Shader:                
        fShaderQuellcode =
            'precision mediump float;\n\
            void main()  \n\
            {     \n\
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\
            } \n';
            

        fShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fShader, fShaderQuellcode);
        gl.compileShader(fShader);
        gl.attachShader(webGLProgramObject, fShader);
        // Das Shader-Program-Objekt ist vollstaendig und muss
        // gelinkt werden.
        gl.linkProgram(webGLProgramObject);
        // Da theoretisch mehrere Shader-Program-Objekte moeglich  
        // sind, muss angegeben werden, welches benutzt werden soll.
        gl.useProgram(webGLProgramObject);
        // RGB-Alpha Farbe zum loeschen des Hintergrundes:
        gl.clearColor(255.0, 255.0,255.0, 1.0);
        // Hintergrund loeschen
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Die Verknuepfung zwischen JavaScript und dem 
        // Shader-Attribut
        vertexAttribLoc = gl.getAttribLocation(webGLProgramObject, "vPosition");

      
		requestAnimationFrame( drawStuff );

    }
    
    function drawStuff(){
    	  	stats.begin();
		
    		interval_counter++;	
			$('#counter').html("Redraw Count:"+interval_counter);	
			stats.begin();
			var points_array = new Array(formated_points_one,formated_points_two);	

			for(var i = 0; i < $("#chanels").val(); i++){
				vVertices = points_array[i];
				//console.log("test");
				
		        // ein WebGL-Buffer-Objekt wird erzeugt:                                          
		        vertexPosBufferObjekt = gl.createBuffer();
		        // ...und als aktives Objekt gesetzt:
		        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBufferObjekt);
		         // die Arraydaten werden an den aktiven Puffer uebergeben:
		        gl.bufferData(gl.ARRAY_BUFFER, vVertices, gl.STATIC_DRAW);
		        gl.vertexAttribPointer(vertexAttribLoc, 3, gl.FLOAT, false, 0, 0);
		        gl.enableVertexAttribArray(vertexAttribLoc);
		
				if($('#limit_lines').val() < vVertices.length/3){
					draw_count = $('#limit_lines').val();
				}else{
					draw_count = vVertices.length/3;
				}
		        gl.drawArrays(gl.LINE_STRIP, 0, draw_count);
	        }
	        stats.end();
	        
	        requestAnimationFrame( drawStuff );
    }
    
	function createPointsArray(chanel){
		console.log(chanel);
		var x_range = 0;
		var points_pixel = points_data;

		var points_string = "-1.0, 1.0,0.0";
		points = new Float32Array(points_pixel.length*3);
		$.each(points_pixel, function(i,val){
			y_range = (val['chanels'][chanel].value/50);
			//console.log(y_range);
			x_range += 0.01;
			points_string += ","+pixelToPoints(i,new Array(x_range,y_range))
		});
    
		return points             
	};
	
	function pixelToPoints(index,point){

		var x = 0;
		var y = 0;
		if(point[0] < canvas.width/2){
		
			if(point[0] > 0){
				x = (100-(((100/(canvas.width/2))*point[0])))*-0.01;
			
			}else{
				x = -1;
			}	
				
			
		}else if(point[0] > canvas.width/2){
			x = ((((100/(canvas.width/2))*point[0])))*0.01;
		}
	
		if(point[1] < canvas.height/2){
			if(point[1] > 0){
				y = (100-(((100/(canvas.height/2))*point[1])))*0.01;
					//console.log("x:"+y);
				
			}else{
				y = -1;
				//console.log(y);
			}	
			
		}else if(point[1] > canvas.height/2){
			y = (100-(((100/(canvas.height/2))*point[1])))*0.01;
		
		}
		//console.log(x+":"+y);
	//console.log(point[1]+":"+y);
		points[(index*3)] = x;
		points[(index*3)+1] = y;
		points[(index*3)+2] = 0.0;

	}

    window.onload = function () {
        //meinWebGLStart();
    };
    </script>
    
    </head>
    <body>
    	<h1 style="text-align:center;">Web GL Path - no simplify</h1>

     <canvas id="meineWebGLCanvas" width="1600" height="500">
     	
     </canvas> 

<p>Data exists for <a id="linescount"></a> Points</p>
<p>Value for max points:<input id="limit_lines" value="50000" type"name"/></p>
<p>Channels: <select id="chanels"><option val="0">1</option><option val="1">2</option></select></p>
<p id="counter"></p>  
     
     
    </body>
</html>

