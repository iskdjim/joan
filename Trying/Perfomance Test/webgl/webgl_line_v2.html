
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
       <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
       <title>WebGL Tutorial 1 - Das erste Dreieck</title>
      <script src="../jquery.min.js"></script>
      	<script src="../app.js"></script>
      	<script src="../stats.js"></script>
    <script type="text/javascript">
    var points_data,stats,formated_points;
       $(document).ready( function() {
        	
        		stats = stats();
			

				$.getJSON( "../api/data.json", function( data ) {
					 canvas = window.document.getElementById("meineWebGLCanvas");
					points_data = data.data;
					formated_points = createPointsArray();
				
					setTimeout(function(){
						
						
						meinWebGLStart(); 
					
					},1000);
				
				})
				
		});	
    
    "use strict";
    /*global window */  // tells jslint that 'window' is defined!
    /*global Float32Array */  // tells jslint that 'Float32Array' is defined!
	var canvas,points;
    // Diese Funktion wird ausgefuehrt, sobald die HTML-Seite geladen ist :
    function meinWebGLStart() {
        var
            gl, // DAS WebGL-Objekt (wird vom Browser abgefragt, falls dieser WebGL unterstützt
            webGLProgramObject, // "GPU-Programm", das zur Berechnung der Grafik verwendet wird
            vShaderQuellcode, // String des Vertex-Shader Quellcodes
            vShader,          // der Shader selbst
            fShaderQuellcode, // String des Fragment-Shader Quellcodes
            fShader,          // der Shader selbst
            vertexAttribLoc,  // Verknüpfung zwischen JavaScript und Vertex-Shader
            vVertices,        // Array der Dreieckskoordinaten
            vertexPosBufferObjekt; // Der WebGL-Buffer, der die Dreieckskoordinaten aufnimmt

       

        try {
            // Falls der Browser es unterstuetzt, wird hier WebGL 
            // erstmalig  angesprochen und der "WebGL-Context" in 
            // dem Objekt gl gespeichert.
            gl = canvas.getContext("experimental-webgl");
        } catch (e) {}
        if (!gl) {
            window.alert("Fehler: WebGL-Context nicht gefunden");
        }

        // Das Shader-Program-Objekt fasst spaeter den Vertex- 
        // und Fragment-Shader zusammen.
        webGLProgramObject = gl.createProgram();

        // Der folgende String enthaelt den kompletten Quellcode
        //  fuer einen minimalistischen Vertex-Shader:  
        vShaderQuellcode =
            'attribute vec4 vPosition; \n\
            void main() \n\
            { \n\
                gl_Position = vPosition; \n\
            } \n';
        // Das Vertex-Shader-Objekt wird angelegt:                                
        vShader = gl.createShader(gl.VERTEX_SHADER);
        //           - mit seinem Quelltext verknuepft:
        gl.shaderSource(vShader, vShaderQuellcode);
        //           - kompiliert:
        gl.compileShader(vShader);
        //           - dem Shader-Program-Objekt hinzugefuegt:
        gl.attachShader(webGLProgramObject, vShader);

        // Nochmal das gleiche Vorgehen wie fuer den Vertex-
        // Shader; analog fuer den Fragment-Shader:                
        fShaderQuellcode =
            'precision mediump float;\n\
            void main()  \n\
            {     \n\
                gl_FragColor = vec4(0.0, 0.0, 255.0, 1.0);\n\
            } \n';
        fShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fShader, fShaderQuellcode);
        gl.compileShader(fShader);
        gl.attachShader(webGLProgramObject, fShader);
        // Das Shader-Program-Objekt ist vollstaendig und muss
        // gelinkt werden.
        gl.linkProgram(webGLProgramObject);
        // Da theoretisch mehrere Shader-Program-Objekte moeglich  
        // sind, muss angegeben werden, welches benutzt werden soll.
        gl.useProgram(webGLProgramObject);
        // RGB-Alpha Farbe zum loeschen des Hintergrundes:
        gl.clearColor(255.0, 255.0,255.0, 1.0);
        // Hintergrund loeschen
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Die Verknuepfung zwischen JavaScript und dem 
        // Shader-Attribut
        vertexAttribLoc = gl.getAttribLocation(webGLProgramObject, "vPosition");
        // Ein Array mit den Koordinaten, der Eckpunkte des Dreiecks
        // das dargestellt wird.
       var interval_counter = 0;
       		
	       vVertices = formated_points;
	       
	       	       
	     
		setInterval(function(){
			interval_counter++;	
			$('#counter').html(interval_counter);	
			stats.begin();
	
	
 			  // ein WebGL-Buffer-Objekt wird erzeugt:                                          
	        vertexPosBufferObjekt = gl.createBuffer();
	        // ...und als aktives Objekt gesetzt:
	        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBufferObjekt);
	         // die Arraydaten werden an den aktiven Puffer uebergeben:
	        gl.bufferData(gl.ARRAY_BUFFER, vVertices, gl.STATIC_DRAW);
	        gl.vertexAttribPointer(vertexAttribLoc, 3, gl.FLOAT, false, 0, 0);
	        gl.enableVertexAttribArray(vertexAttribLoc);
	
			
	        gl.drawArrays(gl.LINE_STRIP, 0, vVertices.length/3);
	        stats.end();
		},1000);
		
    }
    
	function createPointsArray(){
		var x_range = 0;
		var points_pixel = points_data;

		var points_string = "-1.0, 1.0,0.0";
		points = new Float32Array(points_pixel.length*3);
		$.each(points_pixel, function(i,val){
			y_range = (val['chanels'][0].value/50);
			//console.log(y_range);
			x_range += 0.2;
			points_string += ","+pixelToPoints(i,new Array(x_range,y_range))
		});
    
		return points             
	};
	
	function pixelToPoints(index,point){

		var x = 0;
		var y = 0;
		if(point[0] < canvas.width/2){
		
			if(point[0] > 0){
				x = (100-(((100/(canvas.width/2))*point[0])))*-0.01;
			
			}else{
				x = -1;
			}	
				
			
		}else if(point[0] > canvas.width/2){
			x = ((((100/(canvas.width/2))*point[0])))*0.01;
		}
	
		if(point[1] < canvas.height/2){
			if(point[1] > 0){
				y = (100-(((100/(canvas.height/2))*point[1])))*-0.01;
					//console.log("x:"+y);
				
			}else{
				y = -1;
				//console.log(y);
			}	
			
		}else if(point[1] > canvas.height/2){
			y = (100-(((100/(canvas.height/2))*point[1])))*0.01;
		
		}
		//console.log(x+":"+y);
	//console.log(point[1]+":"+y);
		points[(index*3)] = x;
		points[(index*3)+1] = y;
		points[(index*3)+2] = 0.0;

	}

    window.onload = function () {
        //meinWebGLStart();
    };
    </script>
    
    </head>
    <body>
     <canvas id="meineWebGLCanvas" width="1600" height="500">
     	
     </canvas> 
  Anzahl der durchläufe:<p id="counter"></p>  
     
     
    </body>
</html>

